# -*- coding: utf-8 -*-
"""Untitled17.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1l0omG33FZqHtJ0W_22m9pwwPVbLuucTr

#Proyek Kedua : Recomendation System
- Nama: Muhammad Alivian Sidiq
- Email: alivian7373@gmail.com
- ID Dicoding: alivian_7

#Data Understanding

## Import Library
Improt semua library yang digunakan
"""

import numpy as np
import pandas as pd
from sklearn.neighbors import NearestNeighbors
from sklearn.metrics.pairwise import cosine_similarity
import matplotlib.pyplot as plt
import tensorflow as tflw
from tensorflow import keras
from tensorflow.keras import layers

"""## Data Loading
Sumber : MovieLens 20M Datasethttps://www.kaggle.com/datasets/grouplens/movielens-20m-dataset



Read the Dataset
"""

movies = pd.read_csv('movie.csv')
ratings = pd.read_csv('rating.csv')

movies.head()

ratings.head()

"""## Exploratory Data Analysis - Deskripsi Variabel"""

movies.info()

ratings.info()

movies.describe()

ratings.describe()

movies.shape

ratings.shape

"""## Exploratory Data Analysis - Menangani Missing Value"""

movies.duplicated().sum()

ratings.duplicated().sum()

movies.isnull().sum()

ratings.isnull().sum()

"""
## Exploratory Data Analysis - Univariate Analysis"""

# prompt: visualisasikan distribusi rating

plt.hist(ratings['rating'], bins=10)
plt.xlabel('Rating')
plt.ylabel('Frequency')
plt.title('Distribution of Movie Ratings')
plt.show()

plt.figure(figsize=(8, 6))
plt.boxplot(ratings['rating'])
plt.ylabel('Rating')
plt.title('Boxplot Rating')
plt.show()

# Correlation Matrix
correlation_matrix = ratings[['userId', 'movieId', 'rating']].corr()
plt.figure(figsize=(10, 8))
import seaborn as sns
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')
plt.title('Correlation Matrix of UserID, MovieID, and Rating')
plt.show()

"""#Data Preparation"""

genre = movies['genres'].str.split('|', expand=True)

genre

all_genre = set()
for i in genre.columns:
    unique = genre[i].str.lower().str.strip().unique()
    all_genre.update(unique)

all_genre.remove(None)

all_genre

gen_matrix = movies[['movieId','genres']].copy()

gen_matrix['genres'] = gen_matrix['genres'].str.lower().str.strip()

for g in all_genre:
    gen_matrix[g] = np.where(gen_matrix['genres'].str.contains(g), 1, 0)

pd.set_option('display.max_columns', None)

gen_matrix.head()

gen_matrix.drop('genres', axis=1, inplace=True)

gen_matrix = gen_matrix.set_index('movieId')

fix_rating = ratings.sample(n=10000, random_state=42)
print(fix_rating.head())

example_rating = fix_rating.copy()
print(example_rating.head())

# Mengubah user_id menjadi list tanpa nilai yang sama
user_ids = fix_rating['userId'].unique().tolist()
print('list user_id: ', user_ids)

# Melakukan encoding userID
user_to_user_encoded = {x: i for i, x in enumerate(user_ids)}
print('encoded user_id : ', user_to_user_encoded)

# Melakukan proses encoding angka ke ke user_id
user_encoded_to_user = {i: x for i, x in enumerate(user_ids)}
print('encoded angka ke user_id: ', user_encoded_to_user)

movie_ids = fix_rating['movieId'].unique().tolist()

movie_to_movie_encoded = {x: i for i, x in enumerate(movie_ids)}

movie_encoded_to_movie = {i: x for i, x in enumerate(movie_ids)}

fix_rating['user'] = fix_rating['userId'].map(user_to_user_encoded)

fix_rating['movie'] = fix_rating['movieId'].map(movie_to_movie_encoded)

# Mendapatkan jumlah user
num_users = len(user_to_user_encoded)
print(num_users)

# Mendapatkan jumlah movie
num_movie = len(movie_encoded_to_movie)
print(num_movie)

# Mengubah rating menjadi nilai float
fix_rating['rating'] = fix_rating['rating'].values.astype(np.float32)

# Nilai minimum rating
min_rating = min(fix_rating['rating'])

# Nilai maksimal rating
max_rating = max(fix_rating['rating'])

print('Number of User: {}, Number of movie: {}, Min Rating: {}, Max Rating: {}'.format(
    num_users, num_movie, min_rating, max_rating
))

fix_rating

fix_rating = fix_rating.sample(frac=1, random_state=42)
fix_rating

x = fix_rating[['user', 'movie']].values

# Membuat variabel y untuk membuat rating dari hasil
y = fix_rating['rating'].apply(lambda x: (x - min_rating) / (max_rating - min_rating)).values

# Membagi menjadi 80% data train dan 20% data validasi
train_indices = int(0.8 * fix_rating.shape[0])
x_train, x_val, y_train, y_val = (
    x[:train_indices],
    x[train_indices:],
    y[:train_indices],
    y[train_indices:]
)

print(x, y)

corr_matrix = cosine_similarity(gen_matrix)

def top_k_items(corr_mat, item_id, k,map_name):
  top_items = corr_matrix[item_id,:].argsort()[-k:][::-1]
  top_items = [map_name[e] for e in top_items]
  return top_items

ind2mov = {index: movie for index, movie in enumerate(gen_matrix.index)}
mov2ind = {v:k for k, v in ind2mov.items()}

similar_items = top_k_items(item_id=mov2ind[1], k = 10, corr_mat = corr_matrix, map_name = ind2mov)

display(movies.loc[movies['movieId'].isin(similar_items)])

def recommend_movies_by_title(title, k=10):
  try:
    movie_id = movies.loc[movies['title'] == title, 'movieId'].iloc[0]
  except IndexError:
    return pd.DataFrame({'Genre': [], 'Title': []})  # Handle case where title not found

  similar_items = top_k_items(
      item_id=mov2ind[movie_id], k=k+1, corr_mat=corr_matrix, map_name=ind2mov
  )

  print(similar_items)
  recommended_movies = movies.loc[movies['movieId'].isin(similar_items)]
  return recommended_movies[['title', 'year','genres']][1:]


# Example usage:
title_to_recommend_for = 'The Pirates'  # Replace with the desired movie title
recommendations = recommend_movies_by_title(title_to_recommend_for)
print(f"Top 10 recommendations for '{title_to_recommend_for}':")
display(recommendations)

model_knn = NearestNeighbors(metric='cosine', algorithm='brute', n_neighbors=20, n_jobs=-1)
model_knn.fit(gen_matrix)


def recommend_movies_by_title_knn(title, k=10):
  """Recommends top-k movies based on a given movie title using KNN.

  Args:
    title: The title of the movie to find recommendations for.
    k: The number of recommendations to return.

  Returns:
    A DataFrame containing the recommended movies' genre and title.
  """
  try:
    movie_id = movies.loc[movies['title'] == title, 'movieId'].iloc[0]
  except IndexError:
    return pd.DataFrame({'Genre': [], 'Title': []})  # Handle case where title not found

  movie_index = mov2ind[movie_id]
  distances, indices = model_knn.kneighbors(gen_matrix.iloc[[movie_index]], n_neighbors=k + 1)

  similar_movie_indices = indices.flatten()[1:]  # Exclude the input movie itself
  similar_movie_ids = [ind2mov[idx] for idx in similar_movie_indices]

  recommended_movies = movies.loc[movies['movieId'].isin(similar_movie_ids)]
  return recommended_movies[['title', 'year', 'genres']]


# Example usage:
title_to_recommend_for = 'The Pirates'
recommendations_knn = recommend_movies_by_title_knn(title_to_recommend_for)
print(f"Top 10 KNN recommendations for '{title_to_recommend_for}':")
display(recommendations_knn)

class RecommenderNet(tflw.keras.Model):

  # Insialisasi fungsi
  def __init__(self, num_users, num_movie, embedding_size, **kwargs):
    super(RecommenderNet, self).__init__(**kwargs)
    self.num_users = num_users
    self.num_movie = num_movie
    self.embedding_size = embedding_size
    self.user_embedding = layers.Embedding( # layer embedding user
        num_users,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.user_bias = layers.Embedding(num_users, 1) # layer embedding user bias
    self.movie_embedding = layers.Embedding( # layer embeddings
        num_movie,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.movie_bias = layers.Embedding(num_movie, 1) # layer embedding movie bias

  def call(self, inputs):
    user_vector = self.user_embedding(inputs[:,0]) # memanggil layer embedding 1
    user_bias = self.user_bias(inputs[:, 0]) # memanggil layer embedding 2
    movie_vector = self.movie_embedding(inputs[:, 1]) # memanggil layer embedding 3
    movie_bias = self.movie_bias(inputs[:, 1]) # memanggil layer embedding 4

    dot_user_movie = tflw.tensordot(user_vector, movie_vector, 2)

    x = dot_user_movie + user_bias + movie_bias

    return tflw.nn.sigmoid(x) # activation sigmoid

model = RecommenderNet(num_users, num_movie, 50) # inisialisasi model
# model compile

model.compile(
    loss = tflw.keras.losses.BinaryCrossentropy(),
    optimizer = keras.optimizers.Adam(learning_rate=0.001),
    metrics=[tflw.keras.metrics.RootMeanSquaredError()]
)

history = model.fit(
    x = x_train,
    y = y_train,
    batch_size = 32,
    epochs = 100,
    validation_data = (x_val, y_val)
)

movie_df = movies[['movieId', 'title','genres']].copy()
df = example_rating

# Mengambil sample user
user_id = df.userId.sample(1).iloc[0]
movie_visited_by_user = df[df.userId == user_id]

# Operator bitwise (~), bisa diketahui di sini https://docs.python.org/3/reference/expressions.html
movie_not_visited = movie_df[~movie_df['movieId'].isin(movie_visited_by_user.movieId.values)]['movieId']
movie_not_visited = list(
    set(movie_not_visited)
    .intersection(set(movie_to_movie_encoded.keys()))
)

movie_not_visited = [[movie_to_movie_encoded.get(x)] for x in movie_not_visited]
user_encoder = user_to_user_encoded.get(user_id)
user_movie_array = np.hstack(
    ([[user_encoder]] * len(movie_not_visited), movie_not_visited)
)

ratings = model.predict(user_movie_array).flatten()

top_ratings_indices = ratings.argsort()[-10:][::-1]
recommended_movie_ids = [
    movie_encoded_to_movie.get(movie_not_visited[x][0]) for x in top_ratings_indices
]

print('Menampilkan rekomendasi untuk pengguna: {}'.format(user_id))
print('===' * 15)
print('Film dengan rating tertinggi dari pengguna')
print('---' * 15)

top_movie_user = (
    movie_visited_by_user.sort_values(
        by='rating',
        ascending=False
    )
    .head(5)
    .movieId.values
)

movie_df_rows = movie_df[movie_df['movieId'].isin(top_movie_user)]
for row in movie_df_rows.itertuples():
    print(row.title,' : ',row.genres)

print('---' * 15)
print('Rekomendasi 10 film teratas')
print('---' * 15)

recommended_movie = movie_df[movie_df['movieId'].isin(recommended_movie_ids)]
for row in recommended_movie.itertuples():
    print(row.title, ':', row.genres)

plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.title('model_metrics')
plt.ylabel('root_mean_squared_error')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()
